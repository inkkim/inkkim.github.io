I"!<h1 id="️들어가며">🤸‍♂️들어가며</h1>
<p>이 글은 Kubernetes에 대해 공부한 것을 기록하기 위해 작성되었습니다. 혹시 틀린 부분이 있다면 언제든지 댓글을 남겨주세요 😊</p>

<h1 id="kubernetes란-">⛴Kubernetes란 ?</h1>

<h2 id="개요">개요</h2>

<p><img src="https://user-images.githubusercontent.com/60086878/103609779-f2459300-4f61-11eb-951e-8fa51bc3c9e0.png" alt="K8s Logo" /></p>

<p>Kubernetes는 Cotainerized Applications의 배포, 스케일링, 관리 등을 자동화 해주는 오픈 소스 컨테이너 오케스트레이션 엔진입니다. Kubernetes는 앞의 K와 s를 제외한 안쪽 8 글자를 줄여서 <code class="language-plaintext highlighter-rouge">K8s</code>, <code class="language-plaintext highlighter-rouge">케이(에이)츠</code> 라고 부르기도 합니다. 현재 K8s 오픈 소스 프로젝트는 Cloud Native Computing Foundation(CNCF)가 주관하고 있습니다.</p>

<p>K8s의 전신은 Google 내부 프로젝트인 Borg가 전신입니다. 매일 수 억개의 컨테이너를 배포 및 생성하는 플랫폼으로 Google의 십 수년간의 컨테이너 오케스트레이션 노하우 기술이 녹아들어간 기술입니다. 지난 2014년에 Google에서 오픈소스로 공개하여 현재는 여러 IT 대기업들이 개발에 참여하고 있습니다.</p>

<h2 id="탄생-배경">탄생 배경</h2>

<p><img src="https://user-images.githubusercontent.com/60086878/103895670-1c4eaf00-5134-11eb-951c-d24dd925297d.png" alt="image" /></p>

<ul>
  <li>기존의 서버 운영방식</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/60086878/103625188-fa133080-4f7d-11eb-937b-a416a042423e.png" alt="image" /></p>

<p>각 서버마다 운영하는 애플리케이션이 달라 각 서버마다 용도에 맞는 네이밍을 합니다. 즉, 서버 하나에 용도가 한정되며 그에 맞게 관리가 되는 시스템이었습니다. 이러한 이유로 서버마다 특정 애플리케이션을 구동하기 위한 환경이 모두 다르고, 필요한 리소스도 상이합니다. 하지만 이 방법은 관리가 어렵고 안정적인 운영상의 이유로 리소스를 최대로 활용하지 못하는 문제가 있습니다.</p>

<p>이러한 상황에서 만약 서버 A에 문제가 발생한 상황을 가정 해봅시다. 서버 엔지니어는 서버 A에 서비스중인 애플리케이션 A가 지속적으로 배포하기 위해 문제가 된 서버를 복구할 때까지 다른 서버에 배포  해야 합니다. 하지만 다른 서버 역시 별도의 애플리케이션이 서비스중이기 때문에 애플리케이션 A와의 서버 B의 호환여부와 동시에 배포할 수 있는 리소스가 충분한지 여부도 확인해야 하는 매우 번거로운 과정이 따릅니다. 이러한 문제 상황은 언제 어느 서버에서 생길지 모르고, 발생할 때마다 위와 같은 절차가 이뤄지게 되면서 운영상의 어려움과 상당한 비용이 발생합니다.</p>

<ul>
  <li>가상화 기술의 개발</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/60086878/103897289-a4ce4f00-5136-11eb-856c-d1179fba1b36.png" alt="image" /></p>

<p>가상화 기술의 등장으로 한 서버에서 여러 가상 시스템 (VM)을 실행할 수 있게 됐습니다. 이는 기존의 방법보다 리소스를 더 효율적으로 활용할 수 있으며, 쉽게 애플리케이션을 추가하고 업데이트 할 수 있게 됐습니다. 다만, 각 VM은 Host Machine의 하드웨어를 공유하여 운영체제를 병렬로 운영할 수 있어 관리 비용이 줄어든다는 장점이 있지만, 반대로 각각의 VM을 위한 커널이 필요하기 때문에 불필요한 리소스 소모를 감수해야 한다는 단점이 존재한다.</p>

<ul>
  <li>Docker의 등장</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/60086878/103625397-42325300-4f7e-11eb-88dd-16bc55f251a6.png" alt="image" /></p>

<p>리눅스 컨테이너 기술을 적용한 Docker의 등장으로 환경에 상관없이 Docker가 설치되어있는 환경이면 동일하게 애플리케이션을 실행할 수 있게 됐습니다. 컨테이너는 VM과 유사하지만 Host OS 자원인 커널은 공유하고 애플리케이션 단위로 추상화하여 논리적으로 격리시키는 형태입니다. 즉, Hypervisor 없이 Docker Engine만으로 애플리케이션과 바이너리 및 라이브러리가 포함된 컨테이너만 올리면 되는 구조입니다. 이에 따라 특정 OS에 종속되지 않고, 리소스 손실률이 거의 없이 배포할 수 있게 됐습니다.</p>

<p>덕분에 기존보다 관리가 한결 수월하게 됐지만, 컨테이너의 수가 늘어나면서 이것을 관리하는 것조차 어려움이 생겼습니다. 그래서 속속 등장하기 시작한게 컨테이너 오케스트레이션 기술입니다. Kubernetes는 그리스어로 배의 조타수라는 뜻으로, 로고도 조타 핸들 모양을 하고 있습니다.</p>

<ul>
  <li>K8s 클러스터 운영방식</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/60086878/103905066-7b66f080-5141-11eb-8318-d4a19389b91a.png" alt="image" /></p>

<p>K8s는 Master Node에서 Worker Node와 클러스터 내 Pod들을 관리합니다. Worker Node는 컨테이너가 실제 배포되는 곳이며 모든 명령은 Master Node의 API Server와 통신하여 필요한 작업 등을 수행합니다.</p>

<p>K8s 클러스터는 프로덕션 환경에서 배포되는 컨테이너가 정상적으로 가동되고 있는지, 혹시 중단 되었다면 현재 Worker Node 혹은 다른 Node에 리소스가 충분한지 여부를 판단하고, 다시 새로운 컨테이너를 탄력적으로 재가동 해줍니다. K8s 클러스터는 정의된 내용 즉, Desired State에 따라 Current State와 같은지 주기적으로 확인하여 유지하려는 매커니즘으로 관리 됩니다. 즉, 기존에 서버 운영방식에서는 모두 서버 엔지니어가 했던 일들을 K8s 클러스터가 자동으로 관리해주게 되는 것이며, 이를 통해 무중단 배포가 가능해지는 것입니다. 그래서 우리는 이것을 컨테이너 오케스트레이션이라고 합니다.</p>

<h1 id="아키텍쳐">🏗아키텍쳐</h1>

<p><img src="https://user-images.githubusercontent.com/60086878/103619579-5a51a480-4f75-11eb-8a9b-664d1d04cba4.png" alt="image" /></p>

<p>K8s의 컴포넌트는 크게 Master Node에 위치한 Control Plane 영역과 Worker Node 영역으로 구분 됩니다.</p>

<h2 id="control-plane">Control Plane</h2>

<p>Control Plane은 Master Node에서 Worer Node와 클러스터 내 Pod들을 관리합니다. 이를 구성하는 요소들은 다음과 같습니다.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">API Server</code> : K8s 클러스터의 REST API를 제공하는 역할을 합니다. 사용자는 K8s CLI 명령도구인 kubectl을 통해 API Server에 명령을 요청하고, K8s 클러스터 내 대부분의 컴포넌트와 상호작용하는 API Server는 요쳥된 명령을 etcd에 저장한 후 다시 다른 Worker Node 들에게 해당 명령을 전달합니다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">etcd</code> :</p>
  </li>
</ul>

<h2 id="worker-node">Worker Node</h2>

<p><img src="https://user-images.githubusercontent.com/60086878/103901861-0e515c00-513d-11eb-8673-851b85a54213.png" alt="image" /></p>

<p>K8s는 기본적으로 사용자가 정의한 Disired State와 Current State를 유지하는 내용을 골자로 합니다.</p>

<h1 id="대항마">대항마?</h1>

<p><img src="https://user-images.githubusercontent.com/60086878/103619989-0e532f80-4f76-11eb-9ecf-4523d7699dba.png" alt="image" /></p>

<p>이러한 컨테이너 오케스트레이션 플랫폼은 K8s 이외에도 Docker Swarm이나 Apache Mesos와 Marathon 등이 있지만 현재는 K8s가 표준처럼 사용되고 있습니다.</p>

<h1 id="참고">참고</h1>
<p><a href="https://kubernetes.io/docs/home/">Kubernetes Documentation</a>
<a href="https://www.redhat.com/ko/topics/containers/what-is-kubernetes">쿠버네티스(Kubernetes)란? 개념, 성능, 사용방법 및 차이점</a>
<a href="https://subicura.com/2019/05/19/kubernetes-basic-1.html">쿠버네티스 시작하기 - Kubernetes란 무엇인가?</a></p>
:ET